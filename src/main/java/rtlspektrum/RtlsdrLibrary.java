package rtlspektrum;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>rtlsdr</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("rtlsdr") 
@Runtime(CRuntime.class) 
public class RtlsdrLibrary {
	static {
		BridJ.register();
	}
	/**
	 * enum values<br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:195</i>
	 */
	public enum rtlsdr_tuner implements IntValuedEnum<rtlsdr_tuner > {
		RTLSDR_TUNER_UNKNOWN(0),
		RTLSDR_TUNER_E4000(1),
		RTLSDR_TUNER_FC0012(2),
		RTLSDR_TUNER_FC0013(3),
		RTLSDR_TUNER_FC2580(4),
		RTLSDR_TUNER_R820T(5),
		RTLSDR_TUNER_R828D(6);
		rtlsdr_tuner(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<rtlsdr_tuner > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<rtlsdr_tuner > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INTMAX_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_XOPEN2K = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_LEAST64_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST64_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT32_MIN = (int)(-2147483647 - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int WINT_MIN = (int)(0);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __GLIBC_MINOR__ = (int)22;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long WINT_MAX = (long)(4294967295L);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_FAST8_MAX = (int)(127);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT16_MIN = (int)(-32767 - 1);
	/** <i>native declaration : /usr/include/stdc-predef.h</i> */
	public static final int __STDC_NO_THREADS__ = (int)1;
	/** <i>native declaration : /usr/include/bits/wordsize.h</i> */
	public static final int __WORDSIZE_TIME64_COMPAT32 = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT16_MAX = (int)(32767);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int UINT_LEAST8_MAX = (int)(255);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INTPTR_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INTMAX_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INTPTR_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int UINT_FAST8_MAX = (int)(255);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_FAST8_MIN = (int)(-128);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_POSIX = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST8_MAX = (int)(127);
	/** <i>native declaration : /usr/include/bits/wordsize.h</i> */
	public static final int __SYSCALL_WORDSIZE = (int)64;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_ISOC99 = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int SIG_ATOMIC_MIN = (int)(-2147483647 - 1);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_ISOC95 = (int)1;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int _FEATURES_H = (int)1;
	/** <i>native declaration : /usr/include/bits/wordsize.h</i> */
	public static final int __WORDSIZE = (int)64;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_POSIX2 = (int)1;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int _POSIX_SOURCE = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int UINT8_MAX = (int)(255);
	/** <i>native declaration : /usr/include/stdc-predef.h</i> */
	public static final int __STDC_IEC_559__ = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT32_MAX = (int)(2147483647);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_XOPEN2K8 = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int SIG_ATOMIC_MAX = (int)(2147483647);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_ATFILE = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long PTRDIFF_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __GLIBC__ = (int)2;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_FORTIFY_LEVEL = (int)0;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST32_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST16_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/bits/wchar.h</i> */
	public static final int _BITS_WCHAR_H = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long PTRDIFF_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long UINT32_MAX = (long)(4294967295L);
	/** <i>native declaration : /usr/include/stdc-predef.h</i> */
	public static final int __STDC_ISO_10646__ = (int)201304;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int UINT16_MAX = (int)(65535);
	/** <i>native declaration : /usr/include/sys/cdefs.h</i> */
	public static final int _SYS_CDEFS_H = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST32_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/stdc-predef.h</i> */
	public static final int __STDC_IEC_559_COMPLEX__ = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST16_MIN = (int)(-32767 - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int _STDINT_H = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST8_MIN = (int)(-128);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST16_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST16_MAX = (int)(32767);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int _DEFAULT_SOURCE = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT8_MIN = (int)(-128);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int UINT_LEAST16_MAX = (int)(65535);
	/** <i>native declaration : /usr/include/stdc-predef.h</i> */
	public static final int _STDC_PREDEF_H = (int)1;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_POSIX199309 = (int)1;
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_POSIX199506 = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long UINT_LEAST32_MAX = (long)(4294967295L);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_POSIX_IMPLICITLY = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST32_MIN = (int)(-2147483647 - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT8_MAX = (int)(127);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final int INT_LEAST32_MAX = (int)(2147483647);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __USE_MISC = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT64_MIN = (long)(-9223372036854775807L - 1);
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT64_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int _ATFILE_SOURCE = (int)1;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_FAST64_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int __GNU_LIBRARY__ = (int)6;
	/** <i>native declaration : /usr/include/stdint.h</i> */
	public static final long INT_LEAST64_MAX = (long)(9223372036854775807L);
	/** <i>native declaration : /usr/include/features.h</i> */
	public static final int _POSIX_C_SOURCE = (int)200809;
	/** <i>native declaration : /usr/include/rtl-sdr_export.h</i> */
	public static abstract class rtlsdr_read_async_cb_t extends Callback<rtlsdr_read_async_cb_t > {
		public abstract void apply(Pointer buf, int len, Pointer ctx);
	};
	/**
	 * Original signature : <code>uint32_t rtlsdr_get_device_count()</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:51</i>
	 */
	public static native int rtlsdr_get_device_count();
	/**
	 * Original signature : <code>char* rtlsdr_get_device_name(uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:53</i>
	 */
	public static native Pointer rtlsdr_get_device_name(int index);
	/**
	 * Get USB device strings.<br>
	 * * NOTE: The string arguments must provide space for up to 256 bytes.<br>
	 * * \param index the device index<br>
	 * \param manufact manufacturer name, may be NULL<br>
	 * \param product product name, may be NULL<br>
	 * \param serial serial number, may be NULL<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_get_device_usb_strings(uint32_t, char*, char*, char*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:66</i>
	 */
	public static native int rtlsdr_get_device_usb_strings(int index, Pointer manufact, Pointer product, Pointer serial);
	/**
	 * Get device index by USB serial string descriptor.<br>
	 * * \param serial serial string of the device<br>
	 * \return device index of first device where the name matched<br>
	 * \return -1 if name is NULL<br>
	 * \return -2 if no devices were found at all<br>
	 * \return -3 if devices were found, but none with matching name<br>
	 * Original signature : <code>int rtlsdr_get_index_by_serial(const char*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:80</i>
	 */
	public static native int rtlsdr_get_index_by_serial(Pointer serial);
	/**
	 * Original signature : <code>int rtlsdr_open(rtlsdr_dev_t**, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:82</i>
	 */
	public static native int rtlsdr_open(Pointer<Pointer > dev, int index);
	/**
	 * Original signature : <code>int rtlsdr_close(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:84</i>
	 */
	public static native int rtlsdr_close(Pointer dev);
	/**
	 * Set crystal oscillator frequencies used for the RTL2832 and the tuner IC.<br>
	 * * Usually both ICs use the same clock. Changing the clock may make sense if<br>
	 * you are applying an external clock to the tuner or to compensate the<br>
	 * frequency (and samplerate) error caused by the original (cheap) crystal.<br>
	 * * NOTE: Call this function only if you fully understand the implications.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param rtl_freq frequency value used to clock the RTL2832 in Hz<br>
	 * \param tuner_freq frequency value used to clock the tuner IC in Hz<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_xtal_freq(rtlsdr_dev_t*, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:102</i>
	 */
	public static native int rtlsdr_set_xtal_freq(Pointer dev, int rtl_freq, int tuner_freq);
	/**
	 * Get crystal oscillator frequencies used for the RTL2832 and the tuner IC.<br>
	 * * Usually both ICs use the same clock.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param rtl_freq frequency value used to clock the RTL2832 in Hz<br>
	 * \param tuner_freq frequency value used to clock the tuner IC in Hz<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_get_xtal_freq(rtlsdr_dev_t*, uint32_t*, uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:115</i>
	 */
	public static native int rtlsdr_get_xtal_freq(Pointer dev, Pointer<Integer > rtl_freq, Pointer<Integer > tuner_freq);
	/**
	 * Get USB device strings.<br>
	 * * NOTE: The string arguments must provide space for up to 256 bytes.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param manufact manufacturer name, may be NULL<br>
	 * \param product product name, may be NULL<br>
	 * \param serial serial number, may be NULL<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_get_usb_strings(rtlsdr_dev_t*, char*, char*, char*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:129</i>
	 */
	public static native int rtlsdr_get_usb_strings(Pointer dev, Pointer manufact, Pointer product, Pointer serial);
	/**
	 * Original signature : <code>int rtlsdr_write_eeprom(rtlsdr_dev_t*, uint8_t*, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:145</i>
	 */
	public static native int rtlsdr_write_eeprom(Pointer dev, Pointer data, byte offset, short len);
	/**
	 * Original signature : <code>int rtlsdr_read_eeprom(rtlsdr_dev_t*, uint8_t*, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:161</i>
	 */
	public static native int rtlsdr_read_eeprom(Pointer dev, Pointer data, byte offset, short len);
	/**
	 * Original signature : <code>int rtlsdr_set_center_freq(rtlsdr_dev_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:164</i>
	 */
	public static native int rtlsdr_set_center_freq(Pointer dev, int freq);
	/**
	 * Original signature : <code>int rtlsdr_set_if_freq(rtlsdr_dev_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:166</i>
	 */
	public static native int rtlsdr_set_if_freq(Pointer dev, int freq);
	/**
	 * Get actual frequency the device is tuned to.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return 0 on error, frequency in Hz otherwise<br>
	 * Original signature : <code>uint32_t rtlsdr_get_center_freq(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:176</i>
	 */
	public static native int rtlsdr_get_center_freq(Pointer dev);
	/**
	 * Set the frequency correction value for the device.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param ppm correction value in parts per million (ppm)<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_freq_correction(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:185</i>
	 */
	public static native int rtlsdr_set_freq_correction(Pointer dev, int ppm);
	/**
	 * Get actual frequency correction value of the device.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return correction value in parts per million (ppm)<br>
	 * Original signature : <code>int rtlsdr_get_freq_correction(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:193</i>
	 */
	public static native int rtlsdr_get_freq_correction(Pointer dev);
	/**
	 * Get the tuner type.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return RTLSDR_TUNER_UNKNOWN on error, tuner type otherwise<br>
	 * Original signature : <code>rtlsdr_tuner rtlsdr_get_tuner_type(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:211</i>
	 */
	public static native IntValuedEnum<RtlsdrLibrary.rtlsdr_tuner > rtlsdr_get_tuner_type(Pointer dev);
	/**
	 * Get a list of gains supported by the tuner.<br>
	 * * NOTE: The gains argument must be preallocated by the caller. If NULL is<br>
	 * being given instead, the number of available gain values will be returned.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param gains array of gain values. In tenths of a dB, 115 means 11.5 dB.<br>
	 * \return <= 0 on error, number of available (returned) gain values otherwise<br>
	 * Original signature : <code>int rtlsdr_get_tuner_gains(rtlsdr_dev_t*, int*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:223</i>
	 */
	public static native int rtlsdr_get_tuner_gains(Pointer dev, Pointer<Integer > gains);
	/**
	 * Set the gain for the device.<br>
	 * Manual gain mode must be enabled for this to work.<br>
	 * * Valid gain values (in tenths of a dB) for the E4000 tuner:<br>
	 * -10, 15, 40, 65, 90, 115, 140, 165, 190,<br>
	 * 215, 240, 290, 340, 420, 430, 450, 470, 490<br>
	 * * Valid gain values may be queried with \ref rtlsdr_get_tuner_gains function.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param gain in tenths of a dB, 115 means 11.5 dB.<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_tuner_gain(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:239</i>
	 */
	public static native int rtlsdr_set_tuner_gain(Pointer dev, int gain);
	/**
	 * Get actual gain the device is configured to.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return 0 on error, gain in tenths of a dB, 115 means 11.5 dB.<br>
	 * Original signature : <code>int rtlsdr_get_tuner_gain(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:247</i>
	 */
	public static native int rtlsdr_get_tuner_gain(Pointer dev);
	/**
	 * Set the intermediate frequency gain for the device.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param stage intermediate frequency gain stage number (1 to 6 for E4000)<br>
	 * \param gain in tenths of a dB, -30 means -3.0 dB.<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_tuner_if_gain(rtlsdr_dev_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:257</i>
	 */
	public static native int rtlsdr_set_tuner_if_gain(Pointer dev, int stage, int gain);
	/**
	 * Set the gain mode (automatic/manual) for the device.<br>
	 * Manual gain mode must be enabled for the gain setter function to work.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param manual gain mode, 1 means manual gain mode shall be enabled.<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_tuner_gain_mode(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:267</i>
	 */
	public static native int rtlsdr_set_tuner_gain_mode(Pointer dev, int manual);
	/**
	 * Set the sample rate for the device, also selects the baseband filters<br>
	 * according to the requested sample rate for tuners where this is possible.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param samp_rate the sample rate to be set, possible values are:<br>
	 * 		    225001 - 300000 Hz<br>
	 * 		    900001 - 3200000 Hz<br>
	 * 		    sample loss is to be expected for rates > 2400000<br>
	 * \return 0 on success, -EINVAL on invalid rate<br>
	 * Original signature : <code>int rtlsdr_set_sample_rate(rtlsdr_dev_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:280</i>
	 */
	public static native int rtlsdr_set_sample_rate(Pointer dev, int rate);
	/**
	 * Get actual sample rate the device is configured to.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return 0 on error, sample rate in Hz otherwise<br>
	 * Original signature : <code>uint32_t rtlsdr_get_sample_rate(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:288</i>
	 */
	public static native int rtlsdr_get_sample_rate(Pointer dev);
	/**
	 * Enable test mode that returns an 8 bit counter instead of the samples.<br>
	 * The counter is generated inside the RTL2832.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param test mode, 1 means enabled, 0 disabled<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_testmode(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:298</i>
	 */
	public static native int rtlsdr_set_testmode(Pointer dev, int on);
	/**
	 * Enable or disable the internal digital AGC of the RTL2832.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param digital AGC mode, 1 means enabled, 0 disabled<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_agc_mode(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:307</i>
	 */
	public static native int rtlsdr_set_agc_mode(Pointer dev, int on);
	/**
	 * Enable or disable the direct sampling mode. When enabled, the IF mode<br>
	 * of the RTL2832 is activated, and rtlsdr_set_center_freq() will control<br>
	 * the IF-frequency of the DDC, which can be used to tune from 0 to 28.8 MHz<br>
	 * (xtal frequency of the RTL2832).<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param on 0 means disabled, 1 I-ADC input enabled, 2 Q-ADC input enabled<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_direct_sampling(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:319</i>
	 */
	public static native int rtlsdr_set_direct_sampling(Pointer dev, int on);
	/**
	 * Get state of the direct sampling mode<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return -1 on error, 0 means disabled, 1 I-ADC input enabled<br>
	 *     2 Q-ADC input enabled<br>
	 * Original signature : <code>int rtlsdr_get_direct_sampling(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:328</i>
	 */
	public static native int rtlsdr_get_direct_sampling(Pointer dev);
	/**
	 * Enable or disable offset tuning for zero-IF tuners, which allows to avoid<br>
	 * problems caused by the DC offset of the ADCs and 1/f noise.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param on 0 means disabled, 1 enabled<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_offset_tuning(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:338</i>
	 */
	public static native int rtlsdr_set_offset_tuning(Pointer dev, int on);
	/**
	 * Get state of the offset tuning mode<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return -1 on error, 0 means disabled, 1 enabled<br>
	 * Original signature : <code>int rtlsdr_get_offset_tuning(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:346</i>
	 */
	public static native int rtlsdr_get_offset_tuning(Pointer dev);
	/**
	 * Enable or disable frequency dithering for r820t tuners.<br>
	 * Must be performed before freq_set().<br>
	 * Fails for other tuners.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param on 0 means disabled, 1 enabled<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_set_dithering(rtlsdr_dev_t*, int)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:357</i>
	 */
	public static native int rtlsdr_set_dithering(Pointer dev, int dither);
	/**
	 * Original signature : <code>int rtlsdr_reset_buffer(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:361</i>
	 */
	public static native int rtlsdr_reset_buffer(Pointer dev);
	/**
	 * Original signature : <code>int rtlsdr_read_sync(rtlsdr_dev_t*, void*, int, int*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:363</i>
	 */
	public static native int rtlsdr_read_sync(Pointer dev, Pointer buf, int len, Pointer<Integer > n_read);
	/**
	 * Read samples from the device asynchronously. This function will block until<br>
	 * it is being canceled using rtlsdr_cancel_async()<br>
	 * * NOTE: This function is deprecated and is subject for removal.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param cb callback function to return received samples<br>
	 * \param ctx user specific context to pass via the callback function<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_wait_async(rtlsdr_dev_t*, rtlsdr_read_async_cb_t, void*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:378</i>
	 */
	public static native int rtlsdr_wait_async(Pointer dev, Pointer<RtlsdrLibrary.rtlsdr_read_async_cb_t > cb, Pointer ctx);
	/**
	 * Read samples from the device asynchronously. This function will block until<br>
	 * it is being canceled using rtlsdr_cancel_async()<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \param cb callback function to return received samples<br>
	 * \param ctx user specific context to pass via the callback function<br>
	 * \param buf_num optional buffer count, buf_num * buf_len = overall buffer size<br>
	 * 	  set to 0 for default buffer count (15)<br>
	 * \param buf_len optional buffer length, must be multiple of 512,<br>
	 * 	  should be a multiple of 16384 (URB size), set to 0<br>
	 * 	  for default buffer length (16 * 32 * 512)<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_read_async(rtlsdr_dev_t*, rtlsdr_read_async_cb_t, void*, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:394</i>
	 */
	public static native int rtlsdr_read_async(Pointer dev, Pointer<RtlsdrLibrary.rtlsdr_read_async_cb_t > cb, Pointer ctx, int buf_num, int buf_len);
	/**
	 * Cancel all pending asynchronous operations on the device.<br>
	 * * \param dev the device handle given by rtlsdr_open()<br>
	 * \return 0 on success<br>
	 * Original signature : <code>int rtlsdr_cancel_async(rtlsdr_dev_t*)</code><br>
	 * <i>native declaration : /usr/include/rtl-sdr_export.h:406</i>
	 */
	public static native int rtlsdr_cancel_async(Pointer dev);
}
